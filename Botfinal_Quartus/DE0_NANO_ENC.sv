
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE0_NANO_ENC(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	GPIO_0,
	GPIO_0_IN,
	GPIO_1,
	GPIO_1_IN 
	
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		GPIO_0;
input 		     [1:0]		GPIO_0_IN;

inout 		    [33:0]		GPIO_1;
input 		     [1:0]		GPIO_1_IN;

//=======================================================
//  REG/WIRE declarations
//=======================================================

	logic clk;
	logic rst;

	assign clk = CLOCK_50;
	logic [39:0] d ; 
	logic [39:0] q ; 

   logic enc1a, enc1b, enc2a, enc2b, odo1a, odo1b, odo2a, odo2b; 
	
	logic [31:0]countOdo1;
	logic [31:0]countOdo2;
	logic [31:0]countEnc1;
	logic [31:0]countEnc2;
	
	logic [31:0] spi_mem[15:0]; // Stores the datas sent to the de from the Pi 

	logic clock_slow ; 
	logic [31:0]speedOdo1, speedOdo2, speedEnc1, speedEnc2;

	assign enc1a = GPIO_1[33];
	assign enc1b = GPIO_1[31];
	
	assign enc2a = GPIO_1[29];
	assign enc2b = GPIO_1[27];
	
	assign odo1a = GPIO_1[9];
	assign odo1b = GPIO_1[11];
	
	assign odo2a = GPIO_1[13];
	assign odo2b = GPIO_1[15];
	
	assign rst = ~KEY[0];

	clock_divider clock_divider1(
		.clock_in(clk), 
		.clock_out(clock_slow)
	);
	
	quad_dec decoder1(
		.clk  (clk), 
		.reset  (rst),
		.A  (odo1a), 
		.B  (odo1b),
		.count  (countOdo1))
	;

	quad_dec decoder2(
		.clk  (clk), 
		.reset  (rst),
		.A  (odo2a), 
		.B  (odo2b),
		.count  (countOdo2))
	;
	
	quad_dec decoder3(
		.clk  (clk), 
		.reset  (rst),
		.A  (enc1a), 
		.B  (enc1b),
		.count  (countEnc1))
	;

	quad_dec decoder4(
		.clk  (clk), 
		.reset  (rst),
		.A  (enc2a), 
		.B  (enc2b),
		.count  (countEnc2))
	;

	speed_tick_computer stcOdo1(
		.clock_slow(clock_slow), 
		.count(countOdo1), 
		.speed_tick(speedOdo1)
	);
	
	speed_tick_computer stcOdo2(
		.clock_slow(clock_slow), 
		.count(countOdo2), 
		.speed_tick(speedOdo2)
	);

	speed_tick_computer stcEnc1(
		.clock_slow(clock_slow), 
		.count(countEnc1), 
		.speed_tick(speedEnc1)
	);

	speed_tick_computer stcEnc2(
		.clock_slow(clock_slow), 
		.count(countEnc2), 
		.speed_tick(speedEnc2)
	);

//=======================================================
//  SPI
//=======================================================

	logic 			spi_clk, spi_cs, spi_mosi, spi_miso;

	logic [7:0] 	AddressToSend ; 
	logic [7:0] 	AddressReceived ; 
	logic [31:0] 	DataToSend;
	logic [31:0] 	DataReceived;
	
	spi_slave spi_slave_instance(
		.sck    (spi_clk),			 					//input clock given by the master
		.reset  (spi_cs),			 					//input reset signal 
		.mosi   (spi_mosi),			 					//input mosi
		.miso   (spi_miso),			 					//output miso
		.d  	(d),									//input data to send	
		.q 		(q) 									//output data received 
	);

	assign spi_clk   = GPIO_0[11];	// SCLK = pin 13 = miroir pin 23 = GPIO_18
	assign spi_cs    = GPIO_0[9];	// CE1  = pin 15 = miroir pin 25 = GPIO_20
	assign spi_mosi  = GPIO_0[15];	// MOSI = pin 14 = miroir pin 19 = GPIO_24
	assign GPIO_0[13] = spi_cs ? 1'bz : spi_miso ;  // MISO = pin 16 = miroir pin 26 = GPIO_21


//=======================================================
//  Memory
//=======================================================	
	
	always_comb begin
		case(AddressReceived)  
			8'd0 : DataToSend = countOdo1;
			8'd1 : DataToSend = countOdo2;
			
			8'd2 : DataToSend = countEnc1;
			8'd3 : DataToSend = countEnc2;
			
			8'd4 : DataToSend = speedOdo1; 
			8'd5 : DataToSend = speedOdo2; 
			
			8'd6 : DataToSend = speedEnc1; 
			8'd7 : DataToSend = speedEnc2; 
			default: DataToSend = 32'b1111_1111_1111_1111_1111_1111_1111_1111;
		endcase
	end
	
	assign d[39:32] = AddressToSend ; 
	assign d[31:0] = DataToSend ; 
	assign AddressReceived = q[39:32] ; 
	assign DataReceived = q[31:0] ;

//=======================================================
//  LED
//=======================================================

assign LED = speedEnc1[7:0];
	
endmodule